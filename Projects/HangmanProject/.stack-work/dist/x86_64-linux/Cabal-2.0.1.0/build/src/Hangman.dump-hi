
==================== FINAL INTERFACE ====================
2017-12-27 13:19:45.520864 UTC

interface HangmanProject-0.1.0.0-Izv0M6PDQ991in1cSnCpCP:Hangman 8022
  interface hash: 98d0c46e43fb37305ba272a1826d99a0
  ABI hash: 29a9958b3dca60e934239ade4c50704e
  export-list hash: a055178a6f718f0b79712fa5e94ec5b0
  orphan hash: 61c70b3557b8b12f1173d2b04693fabe
  flag hash: d3f9096bac2e1e79f6ff76d0840aa157
  sig of: Nothing
  used TH splices: False
  where
exports:
  Hangman.allWords
  Hangman.alreadyGuessed
  Hangman.charInWord
  Hangman.filepath
  Hangman.fillInCharacter
  Hangman.freshPuzzle
  Hangman.gameOver
  Hangman.gameWin
  Hangman.gameWords
  Hangman.handleGuess
  Hangman.hangman
  Hangman.maxWordLength
  Hangman.minWordLength
  Hangman.numWrongGuesses
  Hangman.randomWord
  Hangman.randomWord'
  Hangman.renderPuzzleChar
  Hangman.runGame
  Hangman.triesAllowed
  Hangman.Puzzle{Hangman.Puzzle}
  Hangman.WordList
module dependencies:
package dependencies: array-0.5.2.0 base-4.10.1.0* deepseq-1.4.3.0
                      ghc-prim-0.5.1.1 integer-gmp-1.0.1.0 random-1.1* time-1.8.0.2
orphans: time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian base-4.10.1.0:GHC.Float
         base-4.10.1.0:GHC.Base
family instance modules: base-4.10.1.0:Control.Applicative
                         base-4.10.1.0:Data.Complex base-4.10.1.0:Data.Either
                         base-4.10.1.0:Data.Functor.Compose base-4.10.1.0:Data.Functor.Const
                         base-4.10.1.0:Data.Functor.Identity
                         base-4.10.1.0:Data.Functor.Product base-4.10.1.0:Data.Functor.Sum
                         base-4.10.1.0:Data.List.NonEmpty base-4.10.1.0:Data.Monoid
                         base-4.10.1.0:Data.Semigroup base-4.10.1.0:Data.Type.Equality
                         base-4.10.1.0:Data.Version base-4.10.1.0:Data.Void
                         base-4.10.1.0:GHC.Exts base-4.10.1.0:GHC.Generics
                         base-4.10.1.0:GHC.IO.Exception base-4.10.1.0:GHC.TypeLits
                         base-4.10.1.0:GHC.TypeNats
import  -/  base-4.10.1.0:Control.Monad ebed2e8e7444944e0c1d827c6faf40a4
import  -/  base-4.10.1.0:Data.Char fe4e3458190deeac19969ce15e33bed9
import  -/  base-4.10.1.0:Data.Foldable 9ed87455d68e87ff2b5b8725eae9897e
import  -/  base-4.10.1.0:Data.List 4ab7fa2a1b87502b23af891a384f0506
import  -/  base-4.10.1.0:Data.Maybe 07738c5485acb328136bb15596f8b845
import  -/  base-4.10.1.0:Data.OldList 555420b092ca8cf0a8f9666bc0e07dcf
import  -/  base-4.10.1.0:GHC.Base 782fd99b5e36f3698a26179a49afca64
import  -/  base-4.10.1.0:GHC.List e3060fbeb44ce0038e6b4dedf2dd9cf1
import  -/  base-4.10.1.0:GHC.Num 6e1dc5d36d99a802edb39b92bb1923b8
import  -/  base-4.10.1.0:GHC.Real 3c62834bc25e762eabc44149c4cc142d
import  -/  base-4.10.1.0:GHC.Show 0a8ce2b5e533d1c2cfb7954e6736be45
import  -/  base-4.10.1.0:Prelude 31945b7d0084063347fc52506d3a4020
import  -/  base-4.10.1.0:System.Exit dfc0230e6f69e5284631635d15ff33dc
import  -/  base-4.10.1.0:System.IO 6e5bb580370d8d71dc5888f723cea4b4
import  -/  ghc-prim-0.5.1.1:GHC.Classes 93e2660065dce9329577e83d76d8f0d4
import  -/  ghc-prim-0.5.1.1:GHC.Types b1fd0716441595db508c1a74387bf394
import  -/  random-1.1:System.Random 7425ef878fcdaaac7b607c0c2d51fc7c
9dca5b2f315d1aa6d34d359aaa885b00
  $fEqPuzzle :: GHC.Classes.Eq Hangman.Puzzle
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Hangman.Puzzle Hangman.$fEqPuzzle_$c== Hangman.$fEqPuzzle_$c/= -}
9dca5b2f315d1aa6d34d359aaa885b00
  $fEqPuzzle_$c/= ::
    Hangman.Puzzle -> Hangman.Puzzle -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U,1*U,1*U)><S(SLL),1*U(1*U,1*U,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Hangman.Puzzle) (b :: Hangman.Puzzle) ->
                 case Hangman.$fEqPuzzle_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
9dca5b2f315d1aa6d34d359aaa885b00
  $fEqPuzzle_$c== ::
    Hangman.Puzzle -> Hangman.Puzzle -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U,1*U,1*U)><S(SLL),1*U(1*U,1*U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Hangman.Puzzle) (w1 :: Hangman.Puzzle) ->
                 case w of ww { Hangman.Puzzle ww1 ww2 ww3 ->
                 case w1 of ww4 { Hangman.Puzzle ww5 ww6 ww7 ->
                 Hangman.$w$c== ww1 ww2 ww3 ww5 ww6 ww7 } }) -}
2654d18e77d3e03799c720c985abc1b9
  $fEqPuzzle_$s$fEqMaybe ::
    GHC.Classes.Eq (GHC.Base.Maybe GHC.Types.Char)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Base.Maybe GHC.Types.Char)
                  (\ (ds :: GHC.Base.Maybe GHC.Types.Char)
                     (ds1 :: GHC.Base.Maybe GHC.Types.Char) ->
                   case ds of wild {
                     GHC.Base.Nothing
                     -> case ds1 of wild1 {
                          GHC.Base.Nothing -> GHC.Types.True
                          GHC.Base.Just ipv -> GHC.Types.False }
                     GHC.Base.Just a1
                     -> case ds1 of wild1 {
                          GHC.Base.Nothing -> GHC.Types.False
                          GHC.Base.Just b1 -> GHC.Classes.eqChar a1 b1 } })
                  (\ (a1 :: GHC.Base.Maybe GHC.Types.Char)
                     (b :: GHC.Base.Maybe GHC.Types.Char) ->
                   case a1 of wild {
                     GHC.Base.Nothing
                     -> case b of wild1 {
                          GHC.Base.Nothing -> GHC.Types.False
                          GHC.Base.Just ipv -> GHC.Types.True }
                     GHC.Base.Just a2
                     -> case b of wild1 {
                          GHC.Base.Nothing -> GHC.Types.True
                          GHC.Base.Just b1
                          -> case GHC.Classes.eqChar a2 b1 of wild2 {
                               GHC.Types.False -> GHC.Types.True
                               GHC.Types.True -> GHC.Types.False } } }) -}
9dca5b2f315d1aa6d34d359aaa885b00
  $fShowPuzzle :: GHC.Show.Show Hangman.Puzzle
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Hangman.Puzzle
                  Hangman.$fShowPuzzle_$cshowsPrec
                  Hangman.$fShowPuzzle_$cshow
                  Hangman.$fShowPuzzle_$cshowList -}
9dca5b2f315d1aa6d34d359aaa885b00
  $fShowPuzzle1 ::
    Hangman.Puzzle -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LSL),1*U(A,1*U,U)><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Hangman.Puzzle) (s :: GHC.Base.String)[OneShot] ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Hangman.$fShowPuzzle_$cshow x))
                   s) -}
a0bc889d72b0d85288243a3a43634d85
  $fShowPuzzle2 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# ' '#) -}
e0038b17c274c353f743703c3ebe74b3
  $fShowPuzzle3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" Guessed so far: "#) -}
9dca5b2f315d1aa6d34d359aaa885b00
  $fShowPuzzle_$cshow :: Hangman.Puzzle -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U,U)>,
     Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Hangman.Puzzle) ->
                 case w of ww { Hangman.Puzzle ww1 ww2 ww3 ->
                 Hangman.$w$cshow ww2 ww3 }) -}
9dca5b2f315d1aa6d34d359aaa885b00
  $fShowPuzzle_$cshowList :: [Hangman.Puzzle] -> GHC.Show.ShowS
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Hangman.Puzzle]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__ @ Hangman.Puzzle Hangman.$fShowPuzzle1 ls s) -}
9dca5b2f315d1aa6d34d359aaa885b00
  $fShowPuzzle_$cshowsPrec ::
    GHC.Types.Int -> Hangman.Puzzle -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,A><S(LSL),1*U(A,1*U,U)><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (x :: Hangman.Puzzle)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Hangman.$fShowPuzzle_$cshow x))
                   s) -}
3de89bf45c4dcee791397de9d12e5f6f
  $tc'Puzzle :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6478510415682823110##
                   3801395201506791295##
                   Hangman.$trModule
                   Hangman.$tc'Puzzle2
                   0#
                   Hangman.$tc'Puzzle1) -}
4c9e7a291f51b3fe70aab0d28d3976b7
  $tc'Puzzle1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
b1941cce8d91e410dc58644710cb9f2e
  $tc'Puzzle2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Hangman.$tc'Puzzle3) -}
60bf938b6788e17ce1fd4af87ebf1043
  $tc'Puzzle3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Puzzle"#) -}
761ec6698065c0b585a41f83ffc9e262
  $tcPuzzle :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11264991708774000070##
                   14734486753832145360##
                   Hangman.$trModule
                   Hangman.$tcPuzzle1
                   0#
                   GHC.Types.krep$*) -}
bad12660fb2ad9404964155f6c8ace14
  $tcPuzzle1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Hangman.$tcPuzzle2) -}
af8c3bf4ad1bdd936c8c5cf20421175a
  $tcPuzzle2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Puzzle"#) -}
0cf06bff945decec94968cc050acd6d4
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Hangman.$trModule3
                   Hangman.$trModule1) -}
28cebce5567d49e206ffe1b7c8d34242
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Hangman.$trModule2) -}
20b7a721497d2f80c42ba5a876eb40e6
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Hangman"#) -}
ec13686d5f55834220e76d68ef233602
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Hangman.$trModule4) -}
50b92674ae2542e275e14d5d6571d350
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("HangmanProject-0.1.0.0-Izv0M6PDQ991in1cSnCpCP"#) -}
cd176379cdd95594aa096c5aa826ba17
  $w$c== ::
    GHC.Base.String
    -> [GHC.Base.Maybe GHC.Types.Char]
    -> [GHC.Types.Char]
    -> GHC.Base.String
    -> [GHC.Base.Maybe GHC.Types.Char]
    -> [GHC.Types.Char]
    -> GHC.Types.Bool
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><L,1*U><S,1*U><L,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Base.String)
                   (ww1 :: [GHC.Base.Maybe GHC.Types.Char])
                   (ww2 :: [GHC.Types.Char])
                   (ww3 :: GHC.Base.String)
                   (ww4 :: [GHC.Base.Maybe GHC.Types.Char])
                   (ww5 :: [GHC.Types.Char]) ->
                 case GHC.Base.eqString ww ww3 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case GHC.Classes.$fEq[]_$c==
                             @ (GHC.Base.Maybe GHC.Types.Char)
                             Hangman.$fEqPuzzle_$s$fEqMaybe
                             ww1
                             ww4 of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True -> GHC.Base.eqString ww2 ww5 } }) -}
f3a03daf66f410fd3afebaad33df7e74
  $w$cshow ::
    [GHC.Base.Maybe GHC.Types.Char]
    -> [GHC.Types.Char] -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: [GHC.Base.Maybe GHC.Types.Char])
                   (ww1 :: [GHC.Types.Char]) ->
                 case GHC.Base.map
                        @ (GHC.Base.Maybe GHC.Types.Char)
                        @ GHC.Types.Char
                        Hangman.renderPuzzleChar
                        ww of wild {
                   [] -> GHC.CString.unpackAppendCString# Hangman.$fShowPuzzle3 ww1
                   : x xs
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        (GHC.Types.:
                           @ GHC.Types.Char
                           x
                           (Data.OldList.prependToAll
                              @ GHC.Types.Char
                              Hangman.$fShowPuzzle2
                              xs))
                        (GHC.CString.unpackAppendCString# Hangman.$fShowPuzzle3 ww1) }) -}
a1403f77975f8a4c2f36a17364ff48f0
  $wgameOver ::
    GHC.Base.String
    -> [GHC.Types.Char]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <L,U><L,U><S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Base.String)
                   (ww1 :: [GHC.Types.Char])
                   (w :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 let {
                   wrongsMade :: GHC.Types.Int
                   = case Hangman.$wnumWrongGuesses ww ww1 of ww2 { DEFAULT ->
                     GHC.Types.I# ww2 }
                 } in
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        (GHC.CString.unpackAppendCString#
                           Hangman.gameOver9
                           (case wrongsMade of ww2 { GHC.Types.I# ww3 ->
                            case GHC.Show.$wshowSignedInt
                                   0#
                                   ww3
                                   (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                            GHC.Types.: @ GHC.Types.Char ww5 ww6 } }))
                        GHC.Types.True
                        w of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        (GHC.CString.unpackAppendCString#
                           Hangman.gameOver8
                           (case wrongsMade of wild1 { GHC.Types.I# y ->
                            case GHC.Show.$wshowSignedInt
                                   0#
                                   (GHC.Prim.+# (GHC.Prim.-# 6# y) 1#)
                                   (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                            GHC.Types.: @ GHC.Types.Char ww5 ww6 } }))
                        GHC.Types.True
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        (GHC.CString.unpackAppendCString#
                           Hangman.gameOver7
                           (case wrongsMade of wild { GHC.Types.I# x ->
                            case x of wild1 {
                              DEFAULT
                              -> GHC.List.$w!!
                                   @ GHC.Base.String
                                   Hangman.hangman
                                   (GHC.Prim.-# wild1 1#)
                              0# -> Hangman.gameOver5 } }))
                        GHC.Types.True
                        ipv2 of ds3 { (#,#) ipv4 ipv5 ->
                 case Hangman.$wnumWrongGuesses ww ww1 of ww2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># ww2 6#) of wild {
                   GHC.Types.False -> (# ipv4, GHC.Tuple.() #)
                   GHC.Types.True
                   -> case GHC.IO.Handle.Text.hPutStr2
                             GHC.IO.Handle.FD.stdout
                             Hangman.gameOver3
                             GHC.Types.True
                             ipv4 of ds4 { (#,#) ipv6 ipv7 ->
                      case GHC.IO.Handle.Text.hPutStr2
                             GHC.IO.Handle.FD.stdout
                             (GHC.CString.unpackAppendCString# Hangman.gameOver2 ww)
                             GHC.Types.True
                             ipv6 of ds5 { (#,#) ipv8 ipv9 ->
                      System.Exit.exitSuccess1 @ () ipv8 } } } } } } }) -}
a9148910703b2de1401f2b2f0666840a
  $wgameWin ::
    GHC.Base.String
    -> [GHC.Base.Maybe GHC.Types.Char]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <L,U><S,1*U><S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Base.String)
                   (ww1 :: [GHC.Base.Maybe GHC.Types.Char])
                   (w :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 let {
                   $j :: (# GHC.Prim.State# GHC.Prim.RealWorld, () #) <join 0>
                   = case GHC.IO.Handle.Text.hPutStr2
                            GHC.IO.Handle.FD.stdout
                            Hangman.gameWin2
                            GHC.Types.True
                            w of ds1 { (#,#) ipv ipv1 ->
                     case GHC.IO.Handle.Text.hPutStr2
                            GHC.IO.Handle.FD.stdout
                            (GHC.CString.unpackAppendCString# Hangman.gameOver2 ww)
                            GHC.Types.True
                            ipv of ds2 { (#,#) ipv2 ipv3 ->
                     System.Exit.exitSuccess1 @ () ipv2 } }
                 } in
                 letrec {
                   go :: [GHC.Base.Maybe GHC.Types.Char]
                         -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [GHC.Base.Maybe GHC.Types.Char]) ->
                     case ds of wild {
                       [] -> $j
                       : y ys
                       -> case y of wild1 {
                            GHC.Base.Nothing -> (# w, GHC.Tuple.() #)
                            GHC.Base.Just ipv -> go ys } }
                 } in
                 go ww1) -}
3d584c03b3a314f82bcbdb3b609cc831
  $wnumWrongGuesses ::
    GHC.Base.String -> [GHC.Types.Char] -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Base.String) (ww1 :: [GHC.Types.Char]) ->
                 case GHC.List.$wlenAcc @ GHC.Types.Char ww1 0# of ww2 { DEFAULT ->
                 letrec {
                   $wgo :: [GHC.Types.Char] -> GHC.Prim.Int# -> GHC.Prim.Int#
                     <join 2> {- Arity: 2, Strictness: <S,1*U><S,U>, Inline: [0] -}
                   = \ (w :: [GHC.Types.Char]) (ww3 :: GHC.Prim.Int#) ->
                     case w of wild {
                       [] -> GHC.Prim.-# ww2 ww3
                       : y ys
                       -> case GHC.List.elem
                                 @ GHC.Types.Char
                                 GHC.Classes.$fEqChar
                                 y
                                 ww of wild1 {
                            GHC.Types.False -> $wgo ys ww3
                            GHC.Types.True -> $wgo ys (GHC.Prim.+# ww3 1#) } }
                 } in
                 $wgo ww1 0# }) -}
9dca5b2f315d1aa6d34d359aaa885b00
  data Puzzle
    = Puzzle GHC.Base.String
             [GHC.Base.Maybe GHC.Types.Char]
             [GHC.Types.Char]
f9794cca4996b9b7224d17edb1f4e8be
  type WordList = [GHC.Base.String]
a129de2b9f9a1c672fe41cf5a3b393bf
  allWords :: GHC.Types.IO Hangman.WordList
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Hangman.allWords1
                  `cast`
                (Sym (GHC.Types.N:IO[0] <Hangman.WordList>_R)) -}
daacbeef327acd7a3df30016f02d2687
  allWords1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Hangman.WordList #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.IO.Handle.FD.openFile1
                        Hangman.filepath
                        GHC.IO.IOMode.ReadMode
                        s of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv1
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 (# ipv2, Data.OldList.lines ipv3 #) } }) -}
ccb77f471c77892c19a6dbb994d023cf
  alreadyGuessed ::
    Hangman.Puzzle -> GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Hangman.Puzzle) (guessLetter :: GHC.Types.Char) ->
                 case ds of wild { Hangman.Puzzle ds1 ds2 guesses ->
                 GHC.List.elem
                   @ GHC.Types.Char
                   GHC.Classes.$fEqChar
                   guessLetter
                   guesses }) -}
06ee6eed846e5169f56971d9673a169e
  charInWord :: Hangman.Puzzle -> GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Hangman.Puzzle) (guessLetter :: GHC.Types.Char) ->
                 case ds of wild { Hangman.Puzzle word ds1 ds2 ->
                 GHC.List.elem
                   @ GHC.Types.Char
                   GHC.Classes.$fEqChar
                   guessLetter
                   word }) -}
98fec0e3caf03e5439dd328e46f8eb72
  filepath :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# Hangman.filepath1) -}
86c7cc3e628cf2a615c7ed2c2c149665
  filepath1 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("/datascience/projects/statisticallyfit/github/learningprogramming/Haskell/HaskellTutorial/src/Projects/HangmanProject/data/dict.txt"#) -}
03c998ad7b79c45f35c216848abc65c7
  fillInCharacter ::
    Hangman.Puzzle -> GHC.Types.Char -> Hangman.Puzzle
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U,1*U,U)><L,U(U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Hangman.Puzzle) (w1 :: GHC.Types.Char) ->
                 case w of ww { Hangman.Puzzle ww1 ww2 ww3 ->
                 Hangman.Puzzle
                   ww1
                   (GHC.List.zipWith
                      @ GHC.Types.Char
                      @ (GHC.Base.Maybe GHC.Types.Char)
                      @ (GHC.Base.Maybe GHC.Types.Char)
                      (\ (wc :: GHC.Types.Char)
                         (dc :: GHC.Base.Maybe GHC.Types.Char)[OneShot] ->
                       case wc of wild { GHC.Types.C# x ->
                       case w1 of wild1 { GHC.Types.C# y ->
                       case GHC.Prim.tagToEnum#
                              @ GHC.Types.Bool
                              (GHC.Prim.eqChar# x y) of wild2 {
                         GHC.Types.False -> dc
                         GHC.Types.True -> GHC.Base.Just @ GHC.Types.Char wild } } })
                      ww1
                      ww2)
                   (GHC.Types.: @ GHC.Types.Char w1 ww3) }) -}
783961a70cb37cd9c90027b860ee337a
  freshPuzzle :: GHC.Base.String -> Hangman.Puzzle
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (word :: GHC.Base.String) ->
                 Hangman.Puzzle
                   word
                   (GHC.Base.build
                      @ (GHC.Base.Maybe GHC.Types.Char)
                      (\ @ b1
                         (c :: GHC.Base.Maybe GHC.Types.Char -> b1 -> b1)[OneShot]
                         (n :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ GHC.Types.Char
                         @ b1
                         (GHC.Base.mapFB
                            @ (GHC.Base.Maybe GHC.Types.Char)
                            @ b1
                            @ GHC.Types.Char
                            c
                            Hangman.freshPuzzle1)
                         n
                         word))
                   (GHC.Types.[] @ GHC.Types.Char)) -}
33052e9fddd9cb4e52f53c8b8d0d9e32
  freshPuzzle1 :: GHC.Types.Char -> GHC.Base.Maybe GHC.Types.Char
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: GHC.Types.Char) -> GHC.Base.Nothing @ GHC.Types.Char) -}
5fa0451d539a5932ed6581b342e5a36f
  gameOver :: Hangman.Puzzle -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <S,1*U(U,A,U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Hangman.gameOver1
                  `cast`
                (<Hangman.Puzzle>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
21212c339c74a20c075b19d1545f09c3
  gameOver1 ::
    Hangman.Puzzle
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <S,1*U(U,A,U)><S,U>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Hangman.Puzzle)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w of ww { Hangman.Puzzle ww1 ww2 ww3 ->
                 Hangman.$wgameOver ww1 ww3 w1 }) -}
0c7b196c7c1b8656d85a543eb8693e8d
  gameOver2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("The word was: "#) -}
e9d7d1f95cc410ddd41e35c622fe19d9
  gameOver3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Hangman.gameOver4) -}
1fb0cf4441c628fb8e8cc8e0093e9338
  gameOver4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("You lose!"#) -}
fffdfec44944e25c635718d1b20aa4fc
  gameOver5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Hangman.gameOver6) -}
17ac02d2d625bb814b667d58e7ace6ce
  gameOver6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("_"#) -}
d736b738d45847aad99e9d6ad9af2d1e
  gameOver7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Limb hung: "#) -}
1a4e451e209cec7222eef34d7d1a3d8f
  gameOver8 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Tries left: "#) -}
c0c3afa0f11f139c8b94515a1cebab4a
  gameOver9 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Current wrong: "#) -}
96349175cef8e2a64d42b77e25aac9f0
  gameWin :: Hangman.Puzzle -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <S(LSL),1*U(U,1*U,A)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Hangman.gameWin1
                  `cast`
                (<Hangman.Puzzle>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
5e42de90c6708d6b251c5589a74394ec
  gameWin1 ::
    Hangman.Puzzle
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <S(LSL),1*U(U,1*U,A)><S,U>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Hangman.Puzzle)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w of ww { Hangman.Puzzle ww1 ww2 ww3 ->
                 Hangman.$wgameWin ww1 ww2 w1 }) -}
a7883e3e69316b8ed5baa31a9a80f4df
  gameWin2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Hangman.gameWin3) -}
2063179a6d966ce75904162ca9660419
  gameWin3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("You win!"#) -}
18d582afd318e6688a83b69425df9a63
  gameWords :: GHC.Types.IO Hangman.WordList
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Hangman.gameWords1
                  `cast`
                (Sym (GHC.Types.N:IO[0] <Hangman.WordList>_R)) -}
0f4b6e2ba635fd7bcdbbae2efc121824
  gameWords1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Hangman.WordList #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.IO.Handle.FD.openFile1
                        Hangman.filepath
                        GHC.IO.IOMode.ReadMode
                        s of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv1
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 (# ipv2,
                    GHC.List.filter
                      @ [GHC.Types.Char]
                      Hangman.gameWords2
                      (Data.OldList.lines ipv3) #) } }) -}
8f3c82392fb13f7dfc78a7c51cb2e2fb
  gameWords2 :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (w :: GHC.Base.String) ->
                 case GHC.List.$wlenAcc @ GHC.Types.Char w 0# of ww2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># ww2 5#) of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# ww2 9#) } }) -}
f1f753ec96404bde139bb443c0cd4ee6
  handleGuess ::
    Hangman.Puzzle -> GHC.Types.Char -> GHC.Types.IO Hangman.Puzzle
  {- Arity: 3, Strictness: <L,1*U(U,U,U)><L,U(U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Hangman.handleGuess1
                  `cast`
                (<Hangman.Puzzle>_R
                 ->_R <GHC.Types.Char>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Hangman.Puzzle>_R)) -}
1110d57ddfbee91074118a9a0745a0ed
  handleGuess1 ::
    Hangman.Puzzle
    -> GHC.Types.Char
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Hangman.Puzzle #)
  {- Arity: 3, Strictness: <L,1*U(U,U,U)><L,U(U)><S,U>,
     Unfolding: (\ (puzzle :: Hangman.Puzzle)
                   (guessLetter :: GHC.Types.Char)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        (GHC.CString.unpackAppendCString#
                           Hangman.handleGuess8
                           (GHC.Types.:
                              @ GHC.Types.Char
                              guessLetter
                              (GHC.Types.[] @ GHC.Types.Char)))
                        GHC.Types.True
                        s of ds1 { (#,#) ipv ipv1 ->
                 case puzzle of wild { Hangman.Puzzle ds ds2 guesses ->
                 case GHC.List.elem
                        @ GHC.Types.Char
                        GHC.Classes.$fEqChar
                        guessLetter
                        guesses of wild1 {
                   GHC.Types.False
                   -> case GHC.List.elem
                             @ GHC.Types.Char
                             GHC.Classes.$fEqChar
                             guessLetter
                             ds of wild2 {
                        GHC.Types.False
                        -> case GHC.IO.Handle.Text.hPutStr2
                                  GHC.IO.Handle.FD.stdout
                                  Hangman.handleGuess6
                                  GHC.Types.True
                                  ipv of ds3 { (#,#) ipv2 ipv3 ->
                           (# ipv2,
                              Hangman.Puzzle
                                ds
                                (GHC.List.zipWith
                                   @ GHC.Types.Char
                                   @ (GHC.Base.Maybe GHC.Types.Char)
                                   @ (GHC.Base.Maybe GHC.Types.Char)
                                   (\ (wc :: GHC.Types.Char)
                                      (dc :: GHC.Base.Maybe GHC.Types.Char)[OneShot] ->
                                    case wc of wild3 { GHC.Types.C# x ->
                                    case guessLetter of wild4 { GHC.Types.C# y ->
                                    case GHC.Prim.tagToEnum#
                                           @ GHC.Types.Bool
                                           (GHC.Prim.eqChar# x y) of wild5 {
                                      GHC.Types.False -> dc
                                      GHC.Types.True -> GHC.Base.Just @ GHC.Types.Char wild3 } } })
                                   ds
                                   ds2)
                                (GHC.Types.: @ GHC.Types.Char guessLetter guesses) #) }
                        GHC.Types.True
                        -> case GHC.IO.Handle.Text.hPutStr2
                                  GHC.IO.Handle.FD.stdout
                                  Hangman.handleGuess4
                                  GHC.Types.True
                                  ipv of ds3 { (#,#) ipv2 ipv3 ->
                           (# ipv2,
                              Hangman.Puzzle
                                ds
                                (GHC.List.zipWith
                                   @ GHC.Types.Char
                                   @ (GHC.Base.Maybe GHC.Types.Char)
                                   @ (GHC.Base.Maybe GHC.Types.Char)
                                   (\ (wc :: GHC.Types.Char)
                                      (dc :: GHC.Base.Maybe GHC.Types.Char)[OneShot] ->
                                    case wc of wild3 { GHC.Types.C# x ->
                                    case guessLetter of wild4 { GHC.Types.C# y ->
                                    case GHC.Prim.tagToEnum#
                                           @ GHC.Types.Bool
                                           (GHC.Prim.eqChar# x y) of wild5 {
                                      GHC.Types.False -> dc
                                      GHC.Types.True -> GHC.Base.Just @ GHC.Types.Char wild3 } } })
                                   ds
                                   ds2)
                                (GHC.Types.: @ GHC.Types.Char guessLetter guesses) #) } }
                   GHC.Types.True
                   -> case GHC.IO.Handle.Text.hPutStr2
                             GHC.IO.Handle.FD.stdout
                             Hangman.handleGuess2
                             GHC.Types.True
                             ipv of ds3 { (#,#) ipv2 ipv3 ->
                      (# ipv2, wild #) } } } }) -}
878cb349b6c9bad992e021e99afc5f66
  handleGuess2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Hangman.handleGuess3) -}
95b7a49f6cb65ace8d957b20919e65df
  handleGuess3 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("ALREADY GUESSED, choose another!"#) -}
ed13d286bf15c53ba07b0637ec506a4e
  handleGuess4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Hangman.handleGuess5) -}
30408360869f847dd745278526a7480e
  handleGuess5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("MATCH! Filling in ..."#) -}
e10d388de4bc4982553962085885bc73
  handleGuess6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Hangman.handleGuess7) -}
bcdaffdc45d8c25451482c7788fa2082
  handleGuess7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("TRY AGAIN"#) -}
217bfe98783aa227c72116eb9b6b5e83
  handleGuess8 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Your guess was: "#) -}
2a67de95774058dd469d485d7d019d6e
  hangman :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Hangman.hangman19
                   Hangman.hangman1) -}
5ddeac777915c0387ee8abe0dd795388
  hangman1 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Hangman.hangman17
                   Hangman.hangman2) -}
7d9f854763b91907e98ea9eb8d5c0831
  hangman10 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("mouth"#) -}
758fed3a51c7e8e0a955c3b1ebbbb42d
  hangman11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Hangman.hangman12) -}
9b7b2b1c0495c6a3b58bd9380fb8a6dc
  hangman12 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("arms"#) -}
76c31f21d01cde73e543e588ab115843
  hangman13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Hangman.hangman14) -}
0ffe839e573ac65af0b429d4a82203b9
  hangman14 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("right foot"#) -}
a647e718926a091383ddd3b3c3d03265
  hangman15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Hangman.hangman16) -}
8f22bdd887b7e1e4ea1fbcc3763b3054
  hangman16 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("left foot"#) -}
a7cb93bdf662f38a8adb605dae569471
  hangman17 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Hangman.hangman18) -}
aff6d724e8bb0f21b66491dc90777817
  hangman18 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("body"#) -}
2f66986d87c6b5355284af12c2b91970
  hangman19 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Hangman.hangman20) -}
83470ea3ea4bca82ca197a84479eb2a7
  hangman2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Hangman.hangman15
                   Hangman.hangman3) -}
d30fac4f8a7e178bf756a7439cbf0417
  hangman20 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("head"#) -}
6e1fc4004da1329ba898128d1fddf1cc
  hangman3 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Hangman.hangman13
                   Hangman.hangman4) -}
1a2c0ab5203c8d8971c84abc0da327ca
  hangman4 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Hangman.hangman11
                   Hangman.hangman5) -}
46be513e658a518e2a3b355544d166d1
  hangman5 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Hangman.hangman9
                   Hangman.hangman6) -}
7ac2ee40ba549332b0a7fe39a903392e
  hangman6 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Hangman.hangman7
                   (GHC.Types.[] @ GHC.Base.String)) -}
d0fabd5ae251a7a20b22e80b840c25ed
  hangman7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Hangman.hangman8) -}
d9e4ca3162c5baca449b5a851d504e7d
  hangman8 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("eyes"#) -}
da788f553d16b5a06c160e76b95ddfe9
  hangman9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Hangman.hangman10) -}
39b82963ae2737fff0059d43f1c64e08
  maxWordLength :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 9#) -}
a3e120e25cde1ac7223fad90ae10cd23
  minWordLength :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 5#) -}
caa9915a7f4f497a19ee1bcd78e938e6
  numWrongGuesses :: Hangman.Puzzle -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(U,A,U)>m,
     Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Hangman.Puzzle) ->
                 case w of ww { Hangman.Puzzle ww1 ww2 ww3 ->
                 case Hangman.$wnumWrongGuesses ww1 ww3 of ww4 { DEFAULT ->
                 GHC.Types.I# ww4 } }) -}
47b16d844435c8a30f818aa1cc6f6f5d
  randomWord :: Hangman.WordList -> GHC.Types.IO GHC.Base.String
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Hangman.randomWord1
                  `cast`
                (<Hangman.WordList>_R
                 ->_R Sym (GHC.Types.N:IO[0] <GHC.Base.String>_R)) -}
845a08211ea5c1cd21ea5c26bbe7f5aa
  randomWord' :: GHC.Types.IO GHC.Base.String
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Hangman.randomWord'1
                  `cast`
                (Sym (GHC.Types.N:IO[0] <GHC.Base.String>_R)) -}
bd9d43ecd48dc9d7a8e2265d323e6f3b
  randomWord'1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Base.String #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.IO.Handle.FD.openFile1
                        Hangman.filepath
                        GHC.IO.IOMode.ReadMode
                        s of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv1
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 Hangman.randomWord1
                   (GHC.Base.build
                      @ [GHC.Types.Char]
                      (\ @ b
                         (c :: [GHC.Types.Char] -> b -> b)[OneShot]
                         (n :: b)[OneShot] ->
                       GHC.Base.foldr
                         @ [GHC.Types.Char]
                         @ b
                         (GHC.List.filterFB @ [GHC.Types.Char] @ b c Hangman.gameWords2)
                         n
                         (Data.OldList.lines ipv3)))
                   ipv2 } }) -}
882b8c466a4dc7907f4d6f2c19c7a0ed
  randomWord1 ::
    Hangman.WordList
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Base.String #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (wordList :: Hangman.WordList)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case System.Random.$fRandomInt3
                        (Hangman.randomWord2,
                         case GHC.List.$wlenAcc
                                @ [GHC.Types.Char]
                                wordList
                                0# of ww2 { DEFAULT ->
                         GHC.Types.I# (GHC.Prim.-# ww2 1#) })
                        s of ds1 { (#,#) ipv ipv1 ->
                 (# ipv, GHC.List.!! @ GHC.Base.String wordList ipv1 #) }) -}
a3ea21ddfabebdded2fd563c358ea7d0
  randomWord2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
1a922edefd3f22b99dd591b78eb03eb3
  renderPuzzleChar :: GHC.Base.Maybe GHC.Types.Char -> GHC.Types.Char
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GHC.Base.Maybe GHC.Types.Char) ->
                 case ds of wild {
                   GHC.Base.Nothing -> Hangman.renderPuzzleChar1
                   GHC.Base.Just c -> c }) -}
e3ca432e2b2a3933ef3187c71a645717
  renderPuzzleChar1 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# '_'#) -}
316ba955024f92e5a7970f10c73af295
  runGame :: Hangman.Puzzle -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,U(U,U,U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Hangman.runGame1
                  `cast`
                (<Hangman.Puzzle>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
d02e186e45c4bc4f1ae4cbb3d094436f
  runGame1 ::
    Hangman.Puzzle
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,U(U,U,U)><S,U> -}
ef3b553b3b381f9e0c54ea17b4151705
  triesAllowed :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 6#) -}
instance [safe] GHC.Classes.Eq [Hangman.Puzzle]
  = Hangman.$fEqPuzzle
instance [safe] GHC.Show.Show [Hangman.Puzzle]
  = Hangman.$fShowPuzzle
"SPEC/Hangman $fEqMaybe @ Char" [orphan] forall (v :: GHC.Classes.Eq
                                                        GHC.Types.Char)
  GHC.Base.$fEqMaybe @ GHC.Types.Char v
  = Hangman.$fEqPuzzle_$s$fEqMaybe
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

