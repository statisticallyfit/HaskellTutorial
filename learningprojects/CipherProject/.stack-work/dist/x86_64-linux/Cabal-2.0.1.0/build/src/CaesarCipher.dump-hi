
==================== FINAL INTERFACE ====================
2018-11-30 09:57:40.97161 UTC

interface CipherProject-0.1.0.0-1WnM0gxR3TI7GmTbdxvJUR:CaesarCipher 8022
  interface hash: 39ad6368fd7078d72ae2ad72ac0e1fa5
  ABI hash: 038b5c53ba13b03e2d47694b84381fb7
  export-list hash: 7854824550f4172b4fee916a36b4a26a
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: d3f9096bac2e1e79f6ff76d0840aa157
  sig of: Nothing
  used TH splices: False
  where
exports:
  CaesarCipher.decode
  CaesarCipher.encode
  CaesarCipher.intToLow
  CaesarCipher.intToUpp
  CaesarCipher.lowToInt
  CaesarCipher.shift
  CaesarCipher.uppToInt
module dependencies:
package dependencies: base-4.10.1.0* ghc-prim-0.5.1.1
                      integer-gmp-1.0.1.0
orphans: base-4.10.1.0:GHC.Float base-4.10.1.0:GHC.Base
family instance modules: base-4.10.1.0:Control.Applicative
                         base-4.10.1.0:Data.Either base-4.10.1.0:Data.Functor.Const
                         base-4.10.1.0:Data.Functor.Identity base-4.10.1.0:Data.Monoid
                         base-4.10.1.0:Data.Type.Equality base-4.10.1.0:GHC.Generics
                         base-4.10.1.0:GHC.IO.Exception base-4.10.1.0:GHC.TypeLits
                         base-4.10.1.0:GHC.TypeNats
import  -/  base-4.10.1.0:Data.Char fe4e3458190deeac19969ce15e33bed9
import  -/  base-4.10.1.0:GHC.Base 782fd99b5e36f3698a26179a49afca64
import  -/  base-4.10.1.0:GHC.Char 630ee80a10729165b02c0abeda9c6526
import  -/  base-4.10.1.0:GHC.Num 6e1dc5d36d99a802edb39b92bb1923b8
import  -/  base-4.10.1.0:GHC.Real 3c62834bc25e762eabc44149c4cc142d
import  -/  base-4.10.1.0:GHC.Unicode 49c9de4fffed0d9be65aaeb6a60b757c
import  -/  base-4.10.1.0:Prelude 31945b7d0084063347fc52506d3a4020
23e89e2f84645cbc7f266665a5c32d03
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   CaesarCipher.$trModule3
                   CaesarCipher.$trModule1) -}
0321284ed4c01d1fa4eeedda4d2bcf31
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS CaesarCipher.$trModule2) -}
54be2e682f5afc05b86e3cee0c071136
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("CaesarCipher"#) -}
8a3b47d71e2a5aa773ee62666325d4fd
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS CaesarCipher.$trModule4) -}
035cc574a67afb7f5bb1d153c67fa6a9
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("CipherProject-0.1.0.0-1WnM0gxR3TI7GmTbdxvJUR"#) -}
7a1bca8c0f4c3a014aba9c9a1cc35d77
  $wshift :: GHC.Types.Int -> GHC.Prim.Char# -> GHC.Prim.Char#
  {- Arity: 2, Strictness: <L,1*U(U)><S,U>, Inline: [0],
     Unfolding: (\ (w :: GHC.Types.Int) (ww :: GHC.Prim.Char#) ->
                 case {__pkg_ccall base-4.10.1.0 GHC.Prim.Int#
                                                 -> GHC.Prim.State# GHC.Prim.RealWorld
                                                 -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                       GHC.Prim.Int# #)}
                        (GHC.Prim.ord# ww)
                        GHC.Prim.realWorld# of wild1 { (#,#) ds ds1 ->
                 case ds1 of wild2 {
                   DEFAULT
                   -> case w of wild4 { GHC.Types.I# y ->
                      case GHC.Classes.modInt#
                             (GHC.Prim.+# (GHC.Prim.-# (GHC.Prim.ord# ww) 97#) y)
                             26# of ww2 { DEFAULT ->
                      let {
                        i# :: GHC.Prim.Int# = GHC.Prim.+# 97# ww2
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.leWord# (GHC.Prim.int2Word# i#) 1114111##) of wild5 {
                        GHC.Types.False
                        -> case GHC.Char.$wlvl i# ret_ty GHC.Prim.Char# of {}
                        GHC.Types.True -> GHC.Prim.chr# i# } } }
                   0#
                   -> case {__pkg_ccall base-4.10.1.0 GHC.Prim.Int#
                                                      -> GHC.Prim.State# GHC.Prim.RealWorld
                                                      -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                            GHC.Prim.Int# #)}
                             (GHC.Prim.ord# ww)
                             GHC.Prim.realWorld# of wild4 { (#,#) ds2 ds3 ->
                      case ds3 of wild5 {
                        DEFAULT
                        -> case w of wild6 { GHC.Types.I# y ->
                           case GHC.Classes.modInt#
                                  (GHC.Prim.+# (GHC.Prim.-# (GHC.Prim.ord# ww) 65#) y)
                                  26# of ww2 { DEFAULT ->
                           let {
                             i# :: GHC.Prim.Int# = GHC.Prim.+# 65# ww2
                           } in
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.leWord# (GHC.Prim.int2Word# i#) 1114111##) of wild7 {
                             GHC.Types.False
                             -> case GHC.Char.$wlvl i# ret_ty GHC.Prim.Char# of {}
                             GHC.Types.True -> GHC.Prim.chr# i# } } }
                        0# -> ww } } } }) -}
ea6fbc802bd12f9e9541bfe91e79579d
  decode :: GHC.Types.Int -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (factor :: GHC.Types.Int) (codedText :: GHC.Base.String) ->
                 GHC.Base.build
                   @ GHC.Types.Char
                   (\ @ b1
                      (c :: GHC.Types.Char -> b1 -> b1)[OneShot]
                      (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b1
                      (GHC.Base.mapFB
                         @ GHC.Types.Char
                         @ b1
                         @ GHC.Types.Char
                         c
                         (CaesarCipher.shift (GHC.Num.$fNumInt_$cnegate factor)))
                      n
                      codedText)) -}
36a4e0803163ea02ea69692869078311
  encode :: GHC.Types.Int -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (factor :: GHC.Types.Int) (originalText :: GHC.Base.String) ->
                 GHC.Base.build
                   @ GHC.Types.Char
                   (\ @ b1
                      (c :: GHC.Types.Char -> b1 -> b1)[OneShot]
                      (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b1
                      (GHC.Base.mapFB
                         @ GHC.Types.Char
                         @ b1
                         @ GHC.Types.Char
                         c
                         (CaesarCipher.shift factor))
                      n
                      originalText)) -}
97895947ffb70ac7b8f2f789a7cda4fa
  intToLow :: GHC.Types.Int -> GHC.Types.Char
  {- Arity: 1, Strictness: <S(S),1*U(U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (n :: GHC.Types.Int) ->
                 case n of wild1 { GHC.Types.I# y ->
                 let {
                   i# :: GHC.Prim.Int# = GHC.Prim.+# 97# y
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.leWord# (GHC.Prim.int2Word# i#) 1114111##) of wild2 {
                   GHC.Types.False -> GHC.Char.$wlvl i#
                   GHC.Types.True -> GHC.Types.C# (GHC.Prim.chr# i#) } }) -}
dfb11e38fdf86288a49c458b11cdf8a5
  intToUpp :: GHC.Types.Int -> GHC.Types.Char
  {- Arity: 1, Strictness: <S(S),1*U(U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (n :: GHC.Types.Int) ->
                 case n of wild1 { GHC.Types.I# y ->
                 let {
                   i# :: GHC.Prim.Int# = GHC.Prim.+# 65# y
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.leWord# (GHC.Prim.int2Word# i#) 1114111##) of wild2 {
                   GHC.Types.False -> GHC.Char.$wlvl i#
                   GHC.Types.True -> GHC.Types.C# (GHC.Prim.chr# i#) } }) -}
1886c025a9a12018b117d682207006ec
  lowToInt :: GHC.Types.Char -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (letter :: GHC.Types.Char) ->
                 case letter of wild { GHC.Types.C# c# ->
                 GHC.Types.I# (GHC.Prim.-# (GHC.Prim.ord# c#) 97#) }) -}
b30b27f753533c570df8124b5acee99c
  shift :: GHC.Types.Int -> GHC.Types.Char -> GHC.Types.Char
  {- Arity: 2, Strictness: <L,1*U(U)><S(S),1*U(U)>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: GHC.Types.Char) ->
                 case w1 of ww { GHC.Types.C# ww1 ->
                 case CaesarCipher.$wshift w ww1 of ww2 { DEFAULT ->
                 GHC.Types.C# ww2 } }) -}
c6e792d670a89d2d4834e32707bbc9b9
  uppToInt :: GHC.Types.Char -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (letter :: GHC.Types.Char) ->
                 case letter of wild { GHC.Types.C# c# ->
                 GHC.Types.I# (GHC.Prim.-# (GHC.Prim.ord# c#) 65#) }) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

