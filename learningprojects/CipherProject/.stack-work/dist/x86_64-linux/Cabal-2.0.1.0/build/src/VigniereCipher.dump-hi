
==================== FINAL INTERFACE ====================
2018-11-30 09:57:41.331834 UTC

interface CipherProject-0.1.0.0-1WnM0gxR3TI7GmTbdxvJUR:VigniereCipher 8022
  interface hash: c81614d8dc612d4d24e6f0ba7e9900c1
  ABI hash: c97c6f06b2d6f13db770129d86961cf6
  export-list hash: 9b8808fa5c0a6177a133fce3cb9c6704
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: d3f9096bac2e1e79f6ff76d0840aa157
  sig of: Nothing
  used TH splices: False
  where
exports:
  VigniereCipher.encodeVigniere
  VigniereCipher.getAllShifts
  VigniereCipher.getKeyShifts
  VigniereCipher.getShift
  VigniereCipher.getSpaces
  VigniereCipher.putSpaces
  VigniereCipher.removeSpaces
  VigniereCipher.replicateKeyWord
  VigniereCipher.Keyword
  VigniereCipher.Shift
  VigniereCipher.Text
module dependencies: CaesarCipher
package dependencies: base-4.10.1.0* ghc-prim-0.5.1.1
                      integer-gmp-1.0.1.0
orphans: base-4.10.1.0:GHC.Float base-4.10.1.0:GHC.Base
family instance modules: base-4.10.1.0:Control.Applicative
                         base-4.10.1.0:Data.Either base-4.10.1.0:Data.Functor.Const
                         base-4.10.1.0:Data.Functor.Identity base-4.10.1.0:Data.Monoid
                         base-4.10.1.0:Data.Type.Equality base-4.10.1.0:GHC.Generics
                         base-4.10.1.0:GHC.IO.Exception base-4.10.1.0:GHC.TypeLits
                         base-4.10.1.0:GHC.TypeNats
import  -/  CaesarCipher 038b5c53ba13b03e2d47694b84381fb7
  exports: 7854824550f4172b4fee916a36b4a26a
  shift b30b27f753533c570df8124b5acee99c
import  -/  base-4.10.1.0:Data.Char fe4e3458190deeac19969ce15e33bed9
import  -/  base-4.10.1.0:Data.Foldable 9ed87455d68e87ff2b5b8725eae9897e
import  -/  base-4.10.1.0:Data.List 4ab7fa2a1b87502b23af891a384f0506
import  -/  base-4.10.1.0:Data.OldList 555420b092ca8cf0a8f9666bc0e07dcf
import  -/  base-4.10.1.0:GHC.Base 782fd99b5e36f3698a26179a49afca64
import  -/  base-4.10.1.0:GHC.List e3060fbeb44ce0038e6b4dedf2dd9cf1
import  -/  base-4.10.1.0:GHC.Num 6e1dc5d36d99a802edb39b92bb1923b8
import  -/  base-4.10.1.0:GHC.Unicode 49c9de4fffed0d9be65aaeb6a60b757c
import  -/  base-4.10.1.0:Prelude 31945b7d0084063347fc52506d3a4020
import  -/  ghc-prim-0.5.1.1:GHC.Classes 93e2660065dce9329577e83d76d8f0d4
8e98339d12972e89d46be1442a75416c
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   VigniereCipher.$trModule3
                   VigniereCipher.$trModule1) -}
6ed707787b3612e2988356baac8ce2cf
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS VigniereCipher.$trModule2) -}
8da79257d93d1a2cace58681942ac219
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("VigniereCipher"#) -}
cc9777dbfdbc11c8bcc38d627778abed
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS VigniereCipher.$trModule4) -}
9758f62f368bac74458d998bb09e8322
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("CipherProject-0.1.0.0-1WnM0gxR3TI7GmTbdxvJUR"#) -}
763eb8941a5a7a45899ba0f3f2507429
  type Keyword = GHC.Base.String
8f00486968dd407ba50160f451d02661
  type Shift = GHC.Types.Int
1c16ec6e5fd8a51c6065b3c04b10d4bf
  type Text = GHC.Base.String
00a08c5dc6197078e61c74b26a5ac86a
  encodeVigniere ::
    VigniereCipher.Text
    -> VigniereCipher.Keyword -> VigniereCipher.Text
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (text :: VigniereCipher.Text)
                   (key :: VigniereCipher.Keyword) ->
                 VigniereCipher.encodeVigniere_go1
                   text
                   (VigniereCipher.encodeVigniere_go2
                      (VigniereCipher.replicateKeyWord text key)
                      VigniereCipher.encodeVigniere_xs)) -}
a9e6b7421e049a21d58dc91f92de475a
  encodeVigniere_go1 ::
    [GHC.Types.Char] -> [GHC.Types.Int] -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
f3a1b3a81ff8ee52ce205c9f15fcaa8f
  encodeVigniere_go2 ::
    [GHC.Types.Char] -> [GHC.Types.Char] -> [GHC.Types.Int]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
8e5b2c355ff98e6d875ffd6b43bc60fe
  encodeVigniere_xs :: [GHC.Types.Char]
  {- HasNoCafRefs, Strictness: m2 -}
d83aeddd14413afd3c61b6838a2bcfc7
  getAllShifts ::
    [(GHC.Types.Char, GHC.Types.Char)] -> [VigniereCipher.Shift]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (pairs :: [(GHC.Types.Char, GHC.Types.Char)]) ->
                 GHC.Base.build
                   @ GHC.Types.Int
                   (\ @ b1
                      (c :: GHC.Types.Int -> b1 -> b1)[OneShot]
                      (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ (GHC.Types.Char, GHC.Types.Char)
                      @ b1
                      (GHC.Base.mapFB
                         @ GHC.Types.Int
                         @ b1
                         @ (GHC.Types.Char, GHC.Types.Char)
                         c
                         VigniereCipher.getShift)
                      n
                      pairs)) -}
50a5bc6dcd357915c8907233d09aeee7
  getKeyShifts :: VigniereCipher.Keyword -> [VigniereCipher.Shift]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (key :: VigniereCipher.Keyword) ->
                 VigniereCipher.encodeVigniere_go2
                   key
                   VigniereCipher.encodeVigniere_xs) -}
8ee1f86b0b2929550debad30917e6ae6
  getShift ::
    (GHC.Types.Char, GHC.Types.Char) -> VigniereCipher.Shift
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(S)S(S)),1*U(1*U(U),1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (GHC.Types.Char, GHC.Types.Char)) ->
                 case ds of wild { (,) a b ->
                 case a of wild1 { GHC.Types.C# c# ->
                 case b of wild2 { GHC.Types.C# c#1 ->
                 let {
                   x1 :: GHC.Prim.Int#
                   = GHC.Prim.-# (GHC.Prim.ord# c#) (GHC.Prim.ord# c#1)
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# x1 0#) of wild3 {
                   GHC.Types.False -> GHC.Types.I# (GHC.Prim.negateInt# x1)
                   GHC.Types.True -> GHC.Types.I# x1 } } } }) -}
a8e6e428554b85b3755de98e80c22692
  getSpaces :: VigniereCipher.Text -> [VigniereCipher.Shift]
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (Data.OldList.findIndices
                   @ GHC.Types.Char
                   VigniereCipher.getSpaces1) -}
e478e1839f9023b4286b92bf0281876e
  getSpaces1 :: GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (GHC.Classes.eqChar VigniereCipher.getSpaces2) -}
dea73c2fdb93200a6fc3b646e4fe4900
  getSpaces2 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# ' '#) -}
a1bbf443dd57e19c91d00ffacc38e035
  putSpaces ::
    [VigniereCipher.Shift]
    -> VigniereCipher.Keyword -> VigniereCipher.Keyword
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
6046c8cc0686f0da0d7b812b647cdfac
  removeSpaces :: VigniereCipher.Text -> VigniereCipher.Text
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (GHC.List.filter
                   @ GHC.Types.Char
                   VigniereCipher.removeSpaces1) -}
b51fff7738682f65bd62f5f4f0a77c4f
  removeSpaces1 :: GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GHC.Types.Char) ->
                 case ds of wild { GHC.Types.C# x1 ->
                 case x1 of wild1 {
                   DEFAULT -> GHC.Types.True ' '# -> GHC.Types.False } }) -}
45178257c7151dddcaeff948dfade7de
  replicateKeyWord ::
    VigniereCipher.Text
    -> VigniereCipher.Keyword -> VigniereCipher.Keyword
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (text :: VigniereCipher.Text)
                   (keyStart :: VigniereCipher.Keyword) ->
                 VigniereCipher.putSpaces
                   (VigniereCipher.replicateKeyWord_go1 text 0#)
                   (case VigniereCipher.replicateKeyWord_go
                           text
                           VigniereCipher.replicateKeyWord1 of wild1 { GHC.Types.I# y ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.<# 0# y) of wild {
                      GHC.Types.False -> GHC.Types.[] @ GHC.Types.Char
                      GHC.Types.True
                      -> letrec {
                           xs :: GHC.Types.Int -> [GHC.Types.Char]
                           = letrec {
                               go :: [GHC.Types.Char] -> GHC.Types.Int -> [GHC.Types.Char]
                                 {- Arity: 1, Strictness: <S,1*U> -}
                               = \ (ds :: [GHC.Types.Char]) ->
                                 case ds of wild2 {
                                   [] -> xs
                                   : y1 ys
                                   -> let {
                                        ys1 :: GHC.Types.Int -> [GHC.Types.Char] = go ys
                                      } in
                                      let {
                                        x1 :: GHC.Types.Char
                                        = case y1 of ww { GHC.Types.C# ww1 ->
                                          case {__pkg_ccall base-4.10.1.0 GHC.Prim.Int#
                                                                          -> GHC.Prim.State#
                                                                               GHC.Prim.RealWorld
                                                                          -> (# GHC.Prim.State#
                                                                                  GHC.Prim.RealWorld,
                                                                                GHC.Prim.Int# #)}
                                                 (GHC.Prim.ord# ww1)
                                                 GHC.Prim.realWorld# of wild3 { (#,#) ds1 ds2 ->
                                          case GHC.Prim.tagToEnum#
                                                 @ GHC.Types.Bool
                                                 (GHC.Prim.leWord#
                                                    (GHC.Prim.int2Word# ds2)
                                                    1114111##) of wild4 {
                                            GHC.Types.False -> GHC.Char.$wlvl ds2
                                            GHC.Types.True -> GHC.Types.C# (GHC.Prim.chr# ds2) } } }
                                      } in
                                      let {
                                        lvl1 :: [GHC.Types.Char]
                                        = GHC.Types.:
                                            @ GHC.Types.Char
                                            x1
                                            (GHC.Types.[] @ GHC.Types.Char)
                                      } in
                                      \ (m :: GHC.Types.Int) ->
                                      case m of wild3 { GHC.Types.I# ds1 ->
                                      case ds1 of ds2 {
                                        DEFAULT
                                        -> GHC.Types.:
                                             @ GHC.Types.Char
                                             x1
                                             (ys1 (GHC.Types.I# (GHC.Prim.-# ds2 1#)))
                                        1# -> lvl1 } } }
                             } in
                             go keyStart
                         } in
                         xs wild1 } })) -}
01514c53ef3f8ef8bc3482e9b8074e4b
  replicateKeyWord1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
cc48589316c9dc32f75e539421073d4c
  replicateKeyWord_go ::
    [GHC.Types.Char] -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 2, Strictness: <S,1*U><L,1*U(U)> -}
5305a6fa86f617fb559c3f9099f4deab
  replicateKeyWord_go1 ::
    [GHC.Types.Char] -> GHC.Prim.Int# -> [GHC.Types.Int]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

