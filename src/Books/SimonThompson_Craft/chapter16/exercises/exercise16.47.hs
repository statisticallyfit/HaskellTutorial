import Data.List (sort, elemIndices, nub)
import Prelude hiding (traverse)
import Test.QuickCheck



{-
NOTE relation {(1,2),(1,3)} means there is arrow from 1 -> 2 and 1 -> 3.
-}

{- ---------------------------------------------------------------------------------------
NOTE KEY OVERALL GOAL: Finding strongly connected components:
1. form relation which links points in the same component
2. then form components (equivalence classes) generated by this relation.
-} ---------------------------------------------------------------------------------------

type Graph a = Relation a

-- note there is a path from x -> y and vice versa if both (x,y) and (y,x) are in
-- the closure
connect :: Ord a => Graph a -> Graph a
connect rel = clos `intersect` invClos
        where clos = transitiveClosure rel
              invClos = inverse clos

{-
Example evaluation
*Main> let s =  (Set [(2,2),(3,4),(5,5)])
*Main> inverse s
Set [(2,2),(4,3),(5,5)]
*Main> intersect it s
Set [(2,2),(5,5)]
-}

inverse :: Ord a => Graph a -> Graph a
inverse = mapSet swap {-rel arg here-}
          where swap (x,y) = (y,x)


-- note to form components from graph: repeatedly add the images under the relation
-- to each of the classes until fixed point is reached.
classes :: Ord a => Graph a -> Set (Set a)
classes rel
    = limit (addImages rel) start
    where start = mapSet sing (vertices rel)

{-
Example evaluation:
*Main> let rr1 = addImages r2 start
*Main> let rr2 = addImages r2 rr1
*Main> let rr3 = addImages r2 rr2
*Main> let rr4 = addImages r2 rr3
*Main> start
Set [Set [1],Set [2],Set [3],Set [4],Set [5],Set [6],Set [7]]
*Main> rr1
Set [Set [1,2,4,6],Set [1,3,6],Set [2,4,5],Set [3,4,5,6,7],Set [5,7],Set [6],Set [6,7]]
*Main> rr2
Set [Set [1,2,3,4,5,6,7],Set [1,2,3,4,6],Set [1,3,4,5,6,7],Set [2,3,4,5,6,7],
Set [5,6,7],Set [6],Set [6,7]]
*Main> rr3
Set [Set [1,2,3,4,5,6,7],Set [5,6,7],Set [6],Set [6,7]]
*Main> rr4
Set [Set [1,2,3,4,5,6,7],Set [5,6,7],Set [6],Set [6,7]]

-}

-- note called "eles" in book.
vertices :: Ord a => Graph a -> Set a
vertices rel = mapSet fst rel `union` mapSet snd rel

addImages :: Ord a => Graph a -> Set (Set a) -> Set (Set a)
addImages rel setOfSets = mapSet (addImage rel) setOfSets








{- ---------------------------------------------------------------------------------------
NOTE overall goal: searching in graphs
-} ---------------------------------------------------------------------------------------

-- note overall: use trans closure to find nodes below a node and in search functions,
-- we find the order in which nodes below ndoes occur.


-- note returns list of num occurs of list (elm : elems) in list xs
-- note ys can be longer than xs since we can return 0 if element in ys doesn't exist
-- in xs.
-- precondition: no list has to be in order.
-- postcondition: length numoccurs == length ys
numOccursAll :: Eq a => [a] -> [a] -> [Int]
numOccursAll xs elements = (map (numOcc xs)) elements
    where numOcc xs elm = length $ elemIndices elm xs

-- note returns elements of s1 which do not belong to s2.
diff :: Ord a => Set a -> Set a -> Set a
diff (Set xs) (Set ys) = Set ans
    where occs = numOccursAll ys xs
          ansPairs = zip xs occs
          ansZeroes = filter (\(x, occ) -> occ == 0) ansPairs
          ans = map fst ansZeroes

------------------------------------------------------------
-- key step for both searches: for a given node, find all its descendants which have
-- not yet been visited.
-- note finds set of descendants of v in rel which are not in the set (set).
newDescs :: Ord a => Graph a -> Set a -> a -> Set a
newDescs rel set node = descendantsOfNodeInRelation `diff` set
    where descendantsOfNodeInRelation = image rel node

-- a flattened version of newDescs (no abstraction barrier)
findDescs :: Ord a => Graph a -> [a] -> a -> [a]
findDescs rel xs node = flatten (newDescs rel (makeSet xs) node)
    where flatten (Set xs) = xs



-- example breadthFirst graph1 1 = [1,2,3,4]
-- note finds all descendants of elements in xs which are not already in xs.
-- Then concat and removeDups. (nub's job)
-- Note: duplicates may occur because a node may be descendant of more than one node.
breadthFirst :: Ord a => Graph a -> a -> [a]
breadthFirst rel node = limit step start
    where start = [node]
          step xs = xs ++ nub (concat (map (findDescs rel xs) xs))


-- example depthFirst graph1 1 = [1,2,4,3]
depthFirst :: Ord a => Graph a -> a -> [a]
depthFirst rel member = depthSearch rel member []

depthSearch rel node visited
    = node : depthList rel (findDescs rel visited' node) visited'
    where visited' = node : visited

-- note finds all descendants of a list of ndoes.
depthList :: Ord a => Graph a -> [a] -> [a] -> [a]
depthList rel [] visited = []
depthList rel (node : restNode) visited
    = next ++ depthList rel restNode (visited ++ next)
    where next = if elem node visited
                 then []
                 else depthSearch rel node visited
 







--- exercoise 47 ------------------------------------------------------------------------

-- note doesn't count link (1,1) since it would loop forever ??)
{-
onePairDistance :: Eq a => Graph a -> (a,a) -> Int
onePairDistance (Set ps) (startEl, endEl)
    | length theEnds == 0 = 1 + minimum ( (map $ onePairDistance (tail ps)) theLinks )
    | otherwise = 2 -- since it took 2 steps.
    where isStart (a,b) = a == startEl
          isLink (a,b) (c,d) = b == c
          isEnd (a,b) = b == endEl
          starts = filter isStart ps
          links = filter isLink ps
          ends = filter isEnd links
-}
{-

onePairDistance :: Eq a => Graph a -> (a,a) -> Int
onePairDistance (Set ps) (startEl, endEl)
    | length endPairs == 0 = 1 + onePairDistance (tail ps)
    where isStart (a,b) = a == startEl
          isLink (a,b) = a == linker
          startPair = head $ filter isStart ps
          linker = snd $ startPair
          linkPair = filter isLink ps
          isEnd (a,b) = b == endEl
          endPairs = filter isEnd linkPair
-}



{-
distance :: Eq a => Graph a -> a -> a -> Int
distance rel startEl endEl
-}





graph1 :: Graph Integer
graph1 = Set [(1,2), (1,3), (3,2), (3,4), (4,2), (2,4),(3,6),(3,9)]

graph2 :: Graph Integer
graph2 = graph1 `union` Set [(4,3)]


r1 :: Relation Integer
r1 = Set [(1,2),(2,3),(3,4)]

r2 :: Relation Integer
r2 = Set [(1,2),(1,4),(1,6),
          (2,4),(2,5),
          (3,1),(3,6),
          (4,3),(4,5),(4,6),(4,7),
          (5,7),
          (7,6)]

famRel :: Relation String
famRel = Set [("Ben", "Sue"), ("Sue", "Joe")] -- ben is father of sue, sue is mother of joe.

sfam :: Set String
sfam = Set ["Joe","Ben"]

-- note first element is parent, second is child. So Ben parent, Sue child.
parentChildPairs :: Relation String
parentChildPairs = Set [("George","Michael"),("Evangeline","Wendy"), ("Gordon", "John"),
            ("Pan","Peter")]

isSib :: Relation String
isSib = Set [("Michael","Wendy"),("Michael","John"),("Wendy", "John"),
    ("Wendy","Michael"),("John", "Michael"),("John","Wendy")]

siblingPairs :: Relation String
siblingPairs = Set [("Fabiana","Milano"), ("Adrianne","Kate"), ("Thalia","Veronique"),
                ("Sara","Berenice"),("David","Julian")]

s1 :: Set String
s1 = Set ["Gabriel", "Evangeline", "George", "Gordon", "Kathryn", "Pan", "Josh",
            "Doreen", "Fabiana", "Thalia", "Julian", "Sara"]

s2 :: Set String
s2 = Set ["Fitz", "Sophie", "Dex", "Keefe", "Biana", "Silveny", "Edaline", "Grady"]





























------------------------------------------------------------------------------------------

-- note set is ordered list of nonduplicate elements
data Set a = Set [a] deriving Show

instance Eq a => Eq (Set a) where
    (==) = eqSet

instance Ord a => Ord (Set a) where
    (<=) = leqSet

empty :: Set a
empty = Set []

sing :: a -> Set a
sing x = Set [x]

-- note is member of this set?
memSet :: Ord a => Set a -> a -> Bool
memSet (Set []) y = False
memSet (Set (x:xs)) y
    | x < y = memSet (Set xs) y
    | x == y = True
    | otherwise = False

union :: Ord a => Set a -> Set a -> Set a
union (Set xs) (Set ys) = Set (uni xs ys)
    where uni [] ys = ys
          uni xs [] = xs
          uni (x:xs) (y:ys)
              | x < y = x : uni xs (y:ys)
              | x == y = x : uni xs ys
              | otherwise = y : uni (x:xs) ys

intersect :: Ord a => Set a -> Set a -> Set a
intersect (Set xs) (Set ys) = Set (int xs ys)
    where int [] ys = []
          int xs [] = []
          int (x:xs) (y:ys)
              | x < y = int xs (y:ys)
              | x == y = x : int xs ys
              | otherwise = int (x:xs) ys

subSet :: Ord a => Set a -> Set a -> Bool
subSet (Set xs) (Set ys) = subS xs ys
    where subS [] ys = True
          subS xs [] = False
          subS (x:xs) (y:ys)
              | x < y = False
              | x == y = subS xs ys
              | otherwise = subS (x:xs) ys

eqSet :: Eq a => Set a -> Set a -> Bool
eqSet (Set xs) (Set ys) = (xs == ys)

-- note less than or equal?
leqSet :: Ord a => Set a -> Set a -> Bool
leqSet (Set xs) (Set ys) = (xs <= ys)

-- note precondition of remDups is sort. that is why we don't need to check x > y
makeSet :: Ord a => [a] -> Set a
makeSet = Set . remDups . sort
    where
    remDups [] = []
    remDups [x] = [x]
    remDups (x:y:xs)
        | x < y = x : remDups (y:xs)
        | otherwise = remDups (y:xs)

mapSet :: Ord b => (a -> b) -> Set a -> Set b
mapSet f (Set xs) = makeSet (map f xs) -- note definition of Functor

filterSet :: (a -> Bool) -> Set a -> Set a
filterSet p (Set xs) = Set (filter p xs)

foldSet :: (a -> a -> a) -> a -> Set a -> a
foldSet f s (Set xs) = foldr f s xs -- note s == seed

-- example: showSet show (Set [1..10]) = 1 ... all on each line.
showSet :: (a -> String) -> Set a -> String
showSet f (Set xs) = concat (map ((++ "\n") . f) xs)

cardinality :: Set a -> Int
cardinality (Set xs) = length xs



------------------------------------------------------------------------------------------


-- relation relates several pairs - gives them a common part.
-- example isParent or isSibling
type Relation a = Set (a, a)
type People = String


-- HELP HELP HELP TODO is this the definition?
isParent :: Relation People
isParent = parentChildPairs

-- example (Ben, Sue) `compose` (Sue, Joe) ==> (Ben, Joe) means (Grandparent, child)
isGrandparent :: Relation People
isGrandparent = isParent `compose` isParent

isSibling :: Relation People
isSibling = siblingPairs

---------------------------------------------------
-- note gets the snd pair element from the given first pair element using the relation.
-- example if we use rel == isParent and val == "George" it returns his child "Michael".
image :: Ord a => Relation a -> a -> Set a
image rel val = mapSet snd (filterSet ((== val) . fst) rel)

-- note returns result of image just applied over a whole set of names. Then unions them.
setImage :: Ord a => Relation a -> Set a -> Set a
setImage rel {-set arg here-} = unionSet . mapSet (image rel) -- set arg here

-- note: takes union of a set.
unionSet :: Ord a => Set (Set a) -> Set a
unionSet = foldSet union empty -- set of set arg here

-- example: addImage famRel sfam = Set ["Joe","Ben", "Sue"]
addImage :: Ord a => Relation a -> Set a -> Set a
addImage rel set = set `union` setImage rel set

-- note returns the snd of pairs from s1 (children) since fsts are parents of snds.
-- Then unions them with the original set s1.
addChildren :: Set People -> Set People
addChildren = addImage isParent

-- note generates all pair combos of pairs and if the inner are equal, then returns
-- the pair of pair's outer elements.
compose :: Ord a => Relation a -> Relation a -> Relation a
compose rel1 rel2
    = mapSet outer (filterSet equals (setProduct rel1 rel2))
    where
    equals ((a,b), (c,d)) = b == c
    outer  ((a,b), (c,d)) = (a,d)


-- note foreach - yields combination of the two sets.
setProduct :: (Ord a, Ord b) => Set a -> Set b -> Set (a,b)
setProduct s1 s2 = unionSet (mapSet (adjoin s1) s2)

-- note adds given element snd in this set for each pair.
adjoin :: (Ord a, Ord b) => Set a -> b -> Set (a,b)
adjoin set el = mapSet (addEl el) set
    where addEl el el' = (el', el)

-- note: given a digraph G(V, E) the transitive closure
-- is a digraph G'(V', E') such that
--- > V' = V (same set of vertices)
--- > If (vi, v(i+1), ..., vk) is a path in G,
--    then (vi, vk) is an edge of E'.
-- note relation is transitive if for all (a,b) and (b,c) in the relation, (a,c)
-- is also in the relation.
-- This means adding length-one path generations.
-- HELP understand role of limit here.
transitiveClosure :: Ord a => Relation a -> Relation a
transitiveClosure rel = limit addGen rel
        where
        --addGen rel = rel `union` (rel `compose` rel)
        addGen rel' = rel' `union` (rel' `compose` rel) -- help todo same as above?

-- note takes first element in the sequence which equals its successor.
limit :: Eq a => (a -> a) -> a -> a
limit f x
    | x == next = x
    | otherwise = limit f next
    where
    next = f x
